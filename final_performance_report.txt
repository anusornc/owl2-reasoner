warning: unused import: `crate::entities::*`
 --> src/reasoning/rules.rs:5:5
  |
5 | use crate::entities::*;
  |     ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `crate::axioms::*`
 --> src/reasoning/consistency.rs:8:5
  |
8 | use crate::axioms::*;
  |     ^^^^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> src/reasoning/consistency.rs:13:24
   |
13 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src/reasoning/consistency.rs:14:5
   |
14 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `crate::entities::*`
 --> src/reasoning/classification.rs:7:5
  |
7 | use crate::entities::*;
  |     ^^^^^^^^^^^^^^^^^^

warning: unused variable: `remaining_tokens`
  --> src/parser/turtle.rs:94:22
   |
94 |         let (object, remaining_tokens) = self.parse_object(&tokens[2..])?;
   |                      ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_remaining_tokens`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `content`
   --> src/parser/turtle.rs:227:42
    |
227 |     fn parse_blank_node_structure(&self, content: &str) -> Option<(NestedObject, usize)> {
    |                                          ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_content`

warning: unused variable: `pos`
  --> src/parser/rdf_xml.rs:96:25
   |
96 |         while let Some((pos, c)) = chars.next() {
   |                         ^^^ help: if this is intentional, prefix it with an underscore: `_pos`

warning: unused variable: `i`
   --> src/parser/rdf_xml.rs:557:18
    |
557 |             for (i, child) in root.children.iter().enumerate() {
    |                  ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `class_iri_str`
   --> src/parser/rdf_xml.rs:625:17
    |
625 |             let class_iri_str = class_iri.to_string();
    |                 ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_class_iri_str`

warning: variable `restriction_type` is assigned to, but never used
   --> src/parser/rdf_xml.rs:725:17
    |
725 |         let mut restriction_type = None;
    |                 ^^^^^^^^^^^^^^^^
    |
    = note: consider using `_restriction_type` instead

warning: variable `restriction_value` is assigned to, but never used
   --> src/parser/rdf_xml.rs:726:17
    |
726 |         let mut restriction_value = None;
    |                 ^^^^^^^^^^^^^^^^^
    |
    = note: consider using `_restriction_value` instead

warning: value assigned to `restriction_type` is never read
   --> src/parser/rdf_xml.rs:737:25
    |
737 |                         restriction_type = Some(child.name.clone());
    |                         ^^^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: value assigned to `restriction_value` is never read
   --> src/parser/rdf_xml.rs:738:25
    |
738 |                         restriction_value = Some(ResourceValue::Resource(self.resolve_iri(resource)?));
    |                         ^^^^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: value assigned to `restriction_type` is never read
   --> src/parser/rdf_xml.rs:743:25
    |
743 |                         restriction_type = Some(child.name.clone());
    |                         ^^^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: value assigned to `restriction_value` is never read
   --> src/parser/rdf_xml.rs:744:25
    |
744 |                         restriction_value = Some(ResourceValue::Resource(self.resolve_iri(resource)?));
    |                         ^^^^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `content`
   --> src/parser/rdf_xml.rs:748:33
    |
748 |                     if let Some(content) = child.attributes.get("rdf:datatype") {
    |                                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_content`

warning: value assigned to `restriction_type` is never read
   --> src/parser/rdf_xml.rs:749:25
    |
749 |                         restriction_type = Some(child.name.clone());
    |                         ^^^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `card_str`
   --> src/parser/rdf_xml.rs:751:37
    |
751 |                         if let Some(card_str) = child.attributes.get("rdf:datatype") {
    |                                     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_card_str`

warning: unused variable: `prop_iri`
   --> src/parser/rdf_xml.rs:761:21
    |
761 |         if let Some(prop_iri) = on_property {
    |                     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_prop_iri`

warning: unused variable: `prop_iri`
   --> src/parser/owl_functional.rs:434:17
    |
434 |             let prop_iri = self.resolve_iri(parts[0])?;
    |                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_prop_iri`

warning: unused variable: `domain_iri`
   --> src/parser/owl_functional.rs:435:17
    |
435 |             let domain_iri = self.resolve_iri(parts[1])?;
    |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_domain_iri`

warning: unused variable: `ontology`
   --> src/parser/owl_functional.rs:431:59
    |
431 |     fn parse_object_property_domain(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                                           ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ontology`

warning: unused variable: `prop_iri`
   --> src/parser/owl_functional.rs:447:17
    |
447 |             let prop_iri = self.resolve_iri(parts[0])?;
    |                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_prop_iri`

warning: unused variable: `range_iri`
   --> src/parser/owl_functional.rs:448:17
    |
448 |             let range_iri = self.resolve_iri(parts[1])?;
    |                 ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_range_iri`

warning: unused variable: `ontology`
   --> src/parser/owl_functional.rs:444:58
    |
444 |     fn parse_object_property_range(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                                          ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ontology`

warning: unused variable: `content`
   --> src/parser/owl_functional.rs:565:42
    |
565 |     fn parse_data_property_domain(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                          ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_content`

warning: unused variable: `ontology`
   --> src/parser/owl_functional.rs:565:57
    |
565 |     fn parse_data_property_domain(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                                         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ontology`

warning: unused variable: `content`
   --> src/parser/owl_functional.rs:572:41
    |
572 |     fn parse_data_property_range(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_content`

warning: unused variable: `ontology`
   --> src/parser/owl_functional.rs:572:56
    |
572 |     fn parse_data_property_range(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                                        ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ontology`

warning: unused variable: `content`
   --> src/parser/owl_functional.rs:601:45
    |
601 |     fn parse_data_property_assertion(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_content`

warning: unused variable: `ontology`
   --> src/parser/owl_functional.rs:601:60
    |
601 |     fn parse_data_property_assertion(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                                            ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ontology`

warning: unused variable: `content`
   --> src/parser/owl_functional.rs:608:56
    |
608 |     fn parse_negative_object_property_assertion(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                                        ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_content`

warning: unused variable: `ontology`
   --> src/parser/owl_functional.rs:608:71
    |
608 |     fn parse_negative_object_property_assertion(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                                                       ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ontology`

warning: unused variable: `content`
   --> src/parser/owl_functional.rs:614:54
    |
614 |     fn parse_negative_data_property_assertion(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                                      ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_content`

warning: unused variable: `ontology`
   --> src/parser/owl_functional.rs:614:69
    |
614 |     fn parse_negative_data_property_assertion(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                                                     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ontology`

warning: unused variable: `content`
   --> src/parser/owl_functional.rs:640:29
    |
640 |     fn parse_has_key(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_content`

warning: unused variable: `ontology`
   --> src/parser/owl_functional.rs:640:44
    |
640 |     fn parse_has_key(&self, content: &str, ontology: &mut Ontology) -> OwlResult<()> {
    |                                            ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ontology`

warning: unused variable: `config`
   --> src/reasoning/tableaux.rs:108:44
    |
108 |     pub fn with_config(ontology: Ontology, config: ReasoningConfig) -> Self {
    |                                            ^^^^^^ help: if this is intentional, prefix it with an underscore: `_config`

warning: unused variable: `new_nodes`
   --> src/reasoning/tableaux.rs:232:21
    |
232 |             let mut new_nodes: Vec<NodeId> = Vec::new();
    |                     ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_nodes`

warning: variable does not need to be mutable
   --> src/reasoning/tableaux.rs:232:17
    |
232 |             let mut new_nodes: Vec<NodeId> = Vec::new();
    |                 ----^^^^^^^^^
    |                 |
    |                 help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `node_id`
   --> src/reasoning/tableaux.rs:579:78
    |
579 |     fn apply_one_of_rule(&self, individuals: &[crate::entities::Individual], node_id: NodeId, graph: &mut TableauxGraph)
    |                                                                              ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_node_id`

warning: unused variable: `graph`
   --> src/reasoning/tableaux.rs:579:95
    |
579 |     fn apply_one_of_rule(&self, individuals: &[crate::entities::Individual], node_id: NodeId, graph: &mut TableauxGraph)
    |                                                                                               ^^^^^ help: if this is intentional, prefix it with an underscore: `_graph`

warning: unused variable: `n`
   --> src/reasoning/tableaux.rs:636:42
    |
636 |     fn apply_max_cardinality_rule(&self, n: usize, property: &ObjectPropertyExpression, filler: &ClassExpression, node_id: NodeId, graph:...
    |                                          ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `property`
   --> src/reasoning/tableaux.rs:636:52
    |
636 |     fn apply_max_cardinality_rule(&self, n: usize, property: &ObjectPropertyExpression, filler: &ClassExpression, node_id: NodeId, graph:...
    |                                                    ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_property`

warning: unused variable: `filler`
   --> src/reasoning/tableaux.rs:636:89
    |
636 | ...: &ObjectPropertyExpression, filler: &ClassExpression, node_id: NodeId, graph: &mut TableauxGraph)
    |                                 ^^^^^^ help: if this is intentional, prefix it with an underscore: `_filler`

warning: unused variable: `node_id`
   --> src/reasoning/tableaux.rs:636:115
    |
636 | ..., filler: &ClassExpression, node_id: NodeId, graph: &mut TableauxGraph)
    |                                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_node_id`

warning: unused variable: `graph`
   --> src/reasoning/tableaux.rs:636:132
    |
636 | ...sExpression, node_id: NodeId, graph: &mut TableauxGraph)
    |                                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_graph`

warning: unused variable: `iri`
   --> src/reasoning/rules.rs:477:34
    |
477 |             PatternVar::Constant(iri) => Ok(var.clone()),
    |                                  ^^^ help: if this is intentional, prefix it with an underscore: `_iri`

warning: field `config` is never read
  --> src/parser/mod.rs:90:5
   |
89 | pub struct NtriplesParser {
   |            -------------- field in this struct
90 |     config: ParserConfig,
   |     ^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: field `0` is never read
   --> src/parser/turtle.rs:596:15
    |
596 |     BlankNode(String),
    |     --------- ^^^^^^
    |     |
    |     field in this variant
    |
    = note: `ObjectValue` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
help: consider changing the field to be of unit type to suppress this warning while preserving the field numbering, or remove the field
    |
596 -     BlankNode(String),
596 +     BlankNode(()),
    |

warning: field `blank_node_counter` is never read
  --> src/parser/rdf_xml.rs:24:5
   |
20 | pub struct RdfXmlParser {
   |            ------------ field in this struct
...
24 |     blank_node_counter: u32,
   |     ^^^^^^^^^^^^^^^^^^

warning: methods `process_disjoint_property_element` and `parse_attributes` are never used
    --> src/parser/rdf_xml.rs:861:8
     |
28   | impl RdfXmlParser {
     | ----------------- methods in this implementation
...
861  |     fn process_disjoint_property_element(&mut self, ontology: &mut Ontology, element: &XmlElement) -> OwlResult<()> {
     |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
1137 |     fn parse_attributes(&mut self, attr_content: &str, element: &mut XmlElement) {
     |        ^^^^^^^^^^^^^^^^

warning: fields `version`, `encoding`, and `standalone` are never read
    --> src/parser/rdf_xml.rs:1224:5
     |
1223 | struct XmlDeclaration {
     |        -------------- fields in this struct
1224 |     version: String,
     |     ^^^^^^^
1225 |     encoding: Option<String>,
     |     ^^^^^^^^
1226 |     standalone: Option<bool>,
     |     ^^^^^^^^^^
     |
     = note: `XmlDeclaration` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `namespace` and `is_empty` are never read
    --> src/parser/rdf_xml.rs:1233:5
     |
1231 | struct XmlElement {
     |        ---------- fields in this struct
1232 |     name: String,
1233 |     namespace: Option<String>,
     |     ^^^^^^^^^
...
1237 |     is_empty: bool,
     |     ^^^^^^^^
     |
     = note: `XmlElement` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `blank_node_id` and `class_expressions` are never read
    --> src/parser/rdf_xml.rs:1244:5
     |
1242 | struct ResourceInfo {
     |        ------------ fields in this struct
1243 |     iri: Option<IRI>,
1244 |     blank_node_id: Option<String>,
     |     ^^^^^^^^^^^^^
...
1247 |     class_expressions: Vec<ClassExpression>,
     |     ^^^^^^^^^^^^^^^^^
     |
     = note: `ResourceInfo` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `property_iri` is never read
    --> src/parser/rdf_xml.rs:1253:5
     |
1252 | struct ResourceProperty {
     |        ---------------- field in this struct
1253 |     property_iri: IRI,
     |     ^^^^^^^^^^^^
     |
     = note: `ResourceProperty` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: variants `BlankNode`, `Literal`, and `ClassExpression` are never constructed
    --> src/parser/rdf_xml.rs:1261:5
     |
1259 | enum ResourceValue {
     |      ------------- variants in this enum
1260 |     Resource(IRI),
1261 |     BlankNode(String),
     |     ^^^^^^^^^
1262 |     Literal(String, Option<String>, Option<IRI>), // value, language, datatype
     |     ^^^^^^^
1263 |     ClassExpression(ClassExpression),
     |     ^^^^^^^^^^^^^^^
     |
     = note: `ResourceValue` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `rules` is never read
  --> src/reasoning/tableaux.rs:18:5
   |
16 | pub struct TableauxReasoner {
   |            ---------------- field in this struct
17 |     pub ontology: Arc<Ontology>,
18 |     rules: ReasoningRules,
   |     ^^^^^

warning: method `are_complementary` is never used
   --> src/reasoning/tableaux.rs:672:8
    |
101 | impl TableauxReasoner {
    | --------------------- method in this implementation
...
672 |     fn are_complementary(&self, a: &ClassExpression, b: &ClassExpression) -> bool {
    |        ^^^^^^^^^^^^^^^^^

warning: fields `name`, `description`, and `priority` are never read
  --> src/reasoning/rules.rs:47:5
   |
46 | pub struct ReasoningRule {
   |            ------------- fields in this struct
47 |     name: String,
   |     ^^^^
48 |     description: String,
   |     ^^^^^^^^^^^
...
51 |     priority: u32,
   |     ^^^^^^^^
   |
   = note: `ReasoningRule` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `satisfiable` is never read
  --> src/reasoning/classification.rs:62:5
   |
52 | pub struct ClassHierarchy {
   |            -------------- field in this struct
...
62 |     satisfiable: HashMap<IRI, bool>,
   |     ^^^^^^^^^^^
   |
   = note: `ClassHierarchy` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: `owl2-reasoner` (lib) generated 62 warnings (run `cargo fix --lib -p owl2-reasoner` to apply 6 suggestions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/examples/advanced_test_runner`
🚀 Advanced OWL2 Test Suite Runner
===================================
Configuration:
  Test files: 7
  Reasoning modes: [Simple, AdvancedTableaux, Hybrid]
  Comprehensive testing: true
  Timeout: 60 seconds

🔬 Running advanced test suite...
This will test each ontology with multiple reasoning modes...

✅ Advanced test suite completed successfully!

Advanced OWL2 Test Suite Results:
  Total Tests: 21
  Passed: 18
  Failed: 3
  Pass Rate: 85.7%
  Execution Time: 43.425459ms
  Reasoning Modes: [Simple, AdvancedTableaux, Hybrid]
  Advanced Reasoning Used: true
  Average Reasoning Time: 37.571µs

📋 Detailed Results Breakdown:
=================================

🎯 Simple Mode Results:
  Tests: 6/7 passed (85.7%)
  Average execution time: 52.017µs
    ✅ PASS test_suite/simple_test.ofn (Simple) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 3
      Classification: 2 classes classified
    ✅ PASS test_suite/family_test.ttl (Simple) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 8 classes classified
    ✅ PASS test_suite/property_test.rdf (Simple) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 3
      Classification: 0 classes classified
    ✅ PASS test_suite/complex_expressions.ttl (Simple) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 0 classes classified
    ✅ PASS test_suite/biomedical_test.ttl (Simple) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 0 classes classified
    ✅ PASS test_suite/classification_test.rdf (Simple) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 22 classes classified
    ❌ FAIL test_suite/inconsistent_test.ofn (Simple) (0)
      Error: Parse error: Unknown prefix: ObjectSomeValuesFrom(

🎯 Hybrid Mode Results:
  Tests: 6/7 passed (85.7%)
  Average execution time: 45.398µs
    ✅ PASS test_suite/simple_test.ofn (Hybrid) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 3
      Classification: 2 classes classified
    ✅ PASS test_suite/family_test.ttl (Hybrid) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 8 classes classified
    ✅ PASS test_suite/property_test.rdf (Hybrid) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 3
      Classification: 0 classes classified
    ✅ PASS test_suite/complex_expressions.ttl (Hybrid) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 0 classes classified
    ✅ PASS test_suite/biomedical_test.ttl (Hybrid) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 0 classes classified
    ✅ PASS test_suite/classification_test.rdf (Hybrid) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 22 classes classified
    ❌ FAIL test_suite/inconsistent_test.ofn (Hybrid) (0)
      Error: Parse error: Unknown prefix: ObjectSomeValuesFrom(

🎯 AdvancedTableaux Mode Results:
  Tests: 6/7 passed (85.7%)
  Average execution time: 15.297µs
    ✅ PASS test_suite/simple_test.ofn (AdvancedTableaux) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 3
      Classification: 2 classes classified
    ✅ PASS test_suite/family_test.ttl (AdvancedTableaux) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 8 classes classified
    ✅ PASS test_suite/property_test.rdf (AdvancedTableaux) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 3
      Classification: 0 classes classified
    ✅ PASS test_suite/complex_expressions.ttl (AdvancedTableaux) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 0 classes classified
    ✅ PASS test_suite/biomedical_test.ttl (AdvancedTableaux) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 0 classes classified
    ✅ PASS test_suite/classification_test.rdf (AdvancedTableaux) (0)
      Consistency: ✅ Consistent
      Satisfiability checks: 5
      Classification: 22 classes classified
    ❌ FAIL test_suite/inconsistent_test.ofn (AdvancedTableaux) (0)
      Error: Parse error: Unknown prefix: ObjectSomeValuesFrom(

🔬 Advanced Reasoning Metrics:
================================
  Total consistency checks: 21
  Total satisfiability checks: 78
  Total classification operations: 18
  Advanced reasoning used: true
  Average reasoning time: 37.571µs

🎯 Advanced Compliance Assessment:
✅ GOOD: 85.7% pass rate - Advanced reasoning is performing well
🚀 Advanced reasoning features are active and functional
🔍 Tableaux-based satisfiability checking is working
📊 Classification reasoning is operational

📄 Generating detailed report...
Report generated successfully!
📄 Detailed report saved to: advanced_test_report.txt
